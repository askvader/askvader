
let concatMap = ./vendor/dhall-lang/Prelude/Text/concatMap

let generate = ./vendor/dhall-lang/Prelude/List/generate

let Functor = ./vendor/dhall-bhat/Functor/Type

let List_functor = ./vendor/dhall-bhat/List/functor

let Applicative = ./vendor/dhall-bhat/Applicative/Type

let liftA2 = ./vendor/dhall-bhat/Applicative/liftA2

let Coyoneda = ./vendor/dhall-bhat/Coyoneda/Type

let liftCoyoneda = ./vendor/dhall-bhat/Coyoneda/lift

let mapCoyoneda =
      λ(f : Type → Type) → (./vendor/dhall-bhat/Coyoneda/functor f).map

let T = Type

let TT = Type → Type

let FreeAp =
        λ(f : TT)
      → λ(a : T)
      → ∀(g : TT) → Applicative g → (∀(x : T) → f x → g x) → g a

let FreeAp_functor
    : ∀(f : TT) → Functor (FreeAp f)
    =   λ(ff : TT)
      → { map =
              λ(a : T)
            → λ(b : T)
            → λ(f : a → b)
            → λ(g : FreeAp ff a)
            →   (   λ(gg : TT)
                  → λ(ggAp : Applicative gg)
                  → λ(k : ∀(x : T) → ff x → gg x)
                  → ggAp.map a b f (g gg ggAp k)
                )
              : FreeAp ff b
        }

let FreeAp_applicative
    : ∀(f : TT) → Applicative (FreeAp f)
    =   λ(ff : TT)
      →   { pure =
                λ(a : Type)
              → λ(x : a)
              →   (   λ(gg : TT)
                    → λ(ggAp : Applicative gg)
                    → λ(k_ : ∀(x : T) → ff x → gg x)
                    → ggAp.pure a x
                  )
                : FreeAp ff a
          , ap =
                λ(a : T)
              → λ(b : T)
              → λ(f : FreeAp ff (a → b))
              → λ(x : FreeAp ff a)
              → λ(gg : TT)
              → λ(ggAp : Applicative gg)
              → λ(k : ∀(x : T) → ff x → gg x)
              → ggAp.ap a b (f gg ggAp k) (x gg ggAp k)
          }
        ∧ FreeAp_functor ff

let liftFreeAp
    : ∀(f : TT) → ∀(a : T) → f a → FreeAp f a
    =   λ(f : TT)
      → λ(a : T)
      → λ(x : f a)
      → λ(g : TT)
      → λ(gAp : Applicative g)
      → λ(k : ∀(x : T) → f x → g x)
      → k a x

let retractFreeAp
    : ∀(f : TT) → ∀(a : T) → ∀(ap : Applicative f) → ∀(fAp : FreeAp f a) → f a
    =   λ(f : TT)
      → λ(a : T)
      → let id = λ(b : T) → λ(x : f b) → x

        in  λ(ap : Applicative f) → λ(fAp : FreeAp f a) → fAp f ap id : f a

let standardProviders =
      ''
      provider "aws" {
        region  = "eu-west-2"
        version = "= 1.54.0"
        profile = "dev"
      }
      provider "null" {
        version = "= 1.0"
      }
      provider "external" {
        version = "= 1.0.0"
      }
      ''

let standardAwsOptions =
      { ami =
          "ami-0dada3805ce43c55e"
      , keyName =
          "admin"
      , instanceType =
          "t2.micro"
      , rootBlockDeviceVolumeSize =
          30
      }

let AwsAttribute =
      < S3BucketId :
          Text
      | S3BucketRegion :
          Text
      | AwsInstancePrivateIp :
          Text
      | AwsIAMUserARN :
          Text
      | AwsIAMUserUniqueId :
          Text
      >

let typeOf =
        λ(x : AwsAttribute)
      → merge
        { S3BucketId =
            λ(_ : Text) → "Text"
        , S3BucketRegion =
            λ(_ : Text) → "Text"
        , AwsInstancePrivateIp =
            λ(_ : Text) → "Text"
        , AwsIAMUserARN =
            λ(_ : Text) → "Text"
        , AwsIAMUserUniqueId =
            λ(_ : Text) → "Text"
        }
        x
        : Text

let AwsAttributes = constructors AwsAttribute

let CannedACL = < Private : {} | PublicRead : {} | PublicReadWrite : {} >

let VersioningOptions = { mfaDelete : Bool }

let S3BucketR =
      { resourceName :
          Text
      , bucketName :
          Optional Text
      , acl :
          Optional CannedACL
      , versioning :
          Optional VersioningOptions
      }

let Blob = List Natural

let S3BucketObjectSource = < Utf8 : Text | Binary : Blob >

let S3BucketObjectR =
      { bucketName : Text, key : Text, source : S3BucketObjectSource }

let Monoid = ./vendor/dhall-bhat/Monoid/Type

let Const = λ(a : Type) → λ(b : Type) → a

let Const_functor =
        λ(x : Type)
      →   { map = λ(a : T) → λ(b : T) → λ(f : a → b) → λ(c : Const x a) → c }
        : Functor (Const x)

let Const_applicative =
        λ(m : Type)
      → λ(mon : Monoid m)
      →     { pure =
                λ(a : T) → λ(x : a) → mon.unit
            , ap =
                  λ(a : T)
                → λ(b : T)
                → λ(cf : Const m (a → b))
                → λ(cx : Const m a)
                → mon.op cf cx
            }
          ∧ Const_functor m
        : Applicative (Const m)

let AwsInstanceConfig = Text

let PrimAttr = < N : Natural | T : Text >

let AttrF = λ(a : Type) → { attrName : Text, attrParse : PrimAttr → Optional a }

let toNix = λ(x : Text) → { nixExpr = x }

let toNix2 = λ(x : Text) → λ(y : Text) → { nixExpr = x ++ " " ++ y }

let toNixShow = λ(x : Natural) → toNix (Natural/show x)

let Attr = FreeAp AttrF

let mapAttr = (FreeAp_functor AttrF).map

let liftA2Attr
    :   ∀(a : Type)
      → ∀(b : Type)
      → ∀(c : Type)
      → (a → b → c)
      → Attr a
      → Attr b
      → Attr c
    = liftA2 Attr (FreeAp_applicative AttrF)

let id = λ(a : Type) → λ(x : a) → x

let someT
    : PrimAttr → Optional Text
    =   λ(x : PrimAttr)
      → merge { T = λ(x : Text) → Some x, N = λ(x : Natural) → None Text } x

let unsafeTextAttr =
        λ(name : Text)
      → liftFreeAp
        AttrF
        Text
        { attrName =
            name
        , attrParse =
              λ(x : PrimAttr)
            → merge
              { T = λ(x : Text) → Some x, N = λ(x : Natural) → None Text }
              x
        }

let someAttr = unsafeTextAttr "thisAttrReturnsText" : Attr Text

let unsafeNatAttr =
        λ(name : Text)
      → liftFreeAp
        AttrF
        Natural
        { attrName =
            name
        , attrParse =
              λ(x : PrimAttr)
            → merge
              { N = λ(x : Natural) → Some x, T = λ(x : Text) → None Natural }
              x
        }

let someNatAttr = unsafeNatAttr "thisAttrReturnsNat" : Attr Natural

let NodeConf = { nixExpr : Text }

let AwsInstanceR =
      { name :
          Text
      , config :
          Attr NodeConf
      , staticFiles :
          List { path : Text, content : Text }
      }

let AwsIAMUserR = { name : Text }

let AwsIAMGroupR = { name : Text, members : List AwsIAMUserR }

let AwsIAMRoleR = { assumeRolePolicy : Text }

let AwsIAMPolicyR = { arn : Text }

let AwsResource =
      < AwsInstance :
          AwsInstanceR
      | S3Bucket :
          S3BucketR
      | S3BucketObject :
          S3BucketObjectR
      | AwsIAMUser :
          AwsIAMUserR
      | AwsIAMGroup :
          AwsIAMGroupR
      | AwsIAMRole :
          AwsIAMRoleR
      | AwsIAMPolicy :
          AwsIAMPolicyR
      >

let AwsResources = constructors AwsResource

let foldMap =
        λ(a : Type)
      → λ(xs : List a)
      → λ(r : Type)
      → λ(m : { empty : r, single : a → r, compose : r → r → r })
      → List/fold a xs r (λ(x : a) → m.compose (m.single x)) m.empty : r

let concatMapSepBy =
        λ(pre : Text)
      → λ(end : Text)
      → λ(delim : Text)
      → λ(a : Type)
      → λ(show : a → Text)
      → λ(xs : List a)
      → let inner =
              foldMap
              a
              xs
              Text
              { empty =
                  ""
              , single =
                  show
              , compose =
                  λ(x : Text) → λ(y : Text) → x ++ delim ++ y
              }

        in  pre ++ inner ++ end : Text

let noFiles = [] : List { content : Text, path : Text }

let EvaluatorInput =
      { tfCodeBefore :
          Text
      , tfCodeAfter :
          Text
      , attrNames :
          List Text
      , tfContinue :
          List PrimAttr → Optional NodeConf
      }

let Optional_monad = ./vendor/dhall-bhat/Optional/monad

let Optional_functor = ./vendor/dhall-bhat/Optional/functor

let StateT = ./vendor/dhall-bhat/StateT/Type

let StateT_applicative =
      ./vendor/dhall-bhat/StateT/applicative
      (List PrimAttr)
      Optional
      Optional_monad

let indexed = ./vendor/dhall-lang/Prelude/List/indexed

let filter = ./vendor/dhall-lang/Prelude/List/filter

let map = ./vendor/dhall-lang/Prelude/List/map

let not = ./vendor/dhall-lang/Prelude/Bool/not

let isZero = ./vendor/dhall-lang/Prelude/Natural/isZero

let uncons
    :   ∀(a : Type)
      → List a
      → ∀(list : Type)
      → ∀(cons : a → List a → list)
      → ∀(nil : list)
      → list
    =   λ(a : T)
      → let tail
            : List a → List a
            =   λ(xs : List a)
              → map
                { value : a, index : Natural }
                a
                (λ(x : { value : a, index : Natural }) → x.value)
                ( filter
                  { value : a, index : Natural }
                  (λ(x : { value : a, index : Natural }) → not (isZero x.index))
                  (indexed a xs)
                )

        in    λ(xs : List a)
            → λ(r : T)
            → λ(cons : a → List a → r)
            → λ(nil : r)
            → List/fold a xs r (λ(x : a) → λ(cs : r) → cons x (tail xs)) nil

let attrParserToState
    : ∀(a : Type) → AttrF a → StateT (List PrimAttr) Optional a
    =   λ(a : T)
      → λ(attr : AttrF a)
      →   (   λ(s : List PrimAttr)
            → uncons
              PrimAttr
              s
              (Optional { val : a, state : List PrimAttr })
              (   λ(x : PrimAttr)
                → λ(xs : List PrimAttr)
                → Optional/fold
                  a
                  (attr.attrParse x)
                  (Optional { val : a, state : List PrimAttr })
                  (λ(x : a) → Some { val = x, state = xs })
                  (None { val : a, state : List PrimAttr })
              )
              (None { val : a, state : List PrimAttr })
          )
        : StateT (List PrimAttr) Optional a

let attrParserToConst
    : ∀(a : Type) → AttrF a → Const (List Text) a
    = λ(a : T) → λ(attr : AttrF a) → [ attr.attrName ]

let runAttr
    : Attr NodeConf → List PrimAttr → Optional NodeConf
    =   λ(attr : Attr NodeConf)
      → λ(inputs : List PrimAttr)
      → let parser
            : StateT (List PrimAttr) Optional NodeConf
            = attr
              (StateT (List PrimAttr) Optional)
              StateT_applicative
              attrParserToState

        in  Optional_functor.map
            { val : NodeConf, state : List PrimAttr }
            NodeConf
            (λ(x : { val : NodeConf, state : List PrimAttr }) → x.val)
            (parser inputs)

let Text_monoid =
      { unit = "", op = λ(x : Text) → λ(y : Text) → x ++ y } : Monoid Text

let List_monoid = ./vendor/dhall-bhat/List/monoid

let getAttrNames
    : Attr NodeConf → List Text
    =   λ(attr : Attr NodeConf)
      → let r
            : Const (List Text) NodeConf
            = attr
              (Const (List Text))
              (Const_applicative (List Text) (List_monoid Text))
              attrParserToConst

        in  r

let awsInstanceToInput
    : AwsInstanceR → EvaluatorInput
    =   λ(instance : AwsInstanceR)
      → { tfCodeBefore =
            "TODO"
        , tfCodeAfter =
            "TODO"
        , attrNames =
            getAttrNames instance.config
        , tfContinue =
            runAttr instance.config
        }

in  ( awsInstanceToInput
      { name =
          "x"
      , staticFiles =
          noFiles
      , config =
          liftA2Attr
          Text
          Text
          NodeConf
          toNix2
          ((FreeAp_applicative AttrF).pure Text "y")
          (mapAttr Natural Text Natural/show someNatAttr)
      }
    ).tfContinue
    ([ PrimAttr.N 2 ] : List PrimAttr)
