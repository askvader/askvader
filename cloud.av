
-- TODO pin prelude using
--    dhall resolve
let
concatMap = https://prelude.dhall-lang.org/Text/concatMap
in
let
generate = https://prelude.dhall-lang.org/List/generate
in


let
Coyoneda = ./vendor/dhall-bhat/Coyoneda/Type
in

-- Terraform providers used by the code we generate
-- Hardcoded for now
let
standardProviders =
  ''
  provider "aws" {
    region  = "eu-west-2"
    version = "= 1.54.0"
    profile = "dev"
  }
  provider "null" {
    version = "= 1.0"
  }
  provider "external" {
    version = "= 1.0.0"
  }
  ''
in

-- Standard AWS options
-- Hardcoded for now
let
standardAwsOptions =
  -- AMI from https://nixos.org/nixos/download.html
  -- Nixos 18.09
  { ami = "ami-0dada3805ce43c55e"
  , keyName = "admin"
	, instanceType = "t2.micro"
	-- , instanceType = "t2.medium"
  -- instance_type   = "m5d.2xlarge"
	-- , instanceType   = "t2.medium"
		-- instance_type = "i3.xlarge"
    --
  -- In GB
  , rootBlockDeviceVolumeSize = 30 -- TODO too big?
  }
in







--
-- AWS
--
-- TODO flatten for easier construction
-- Could also provide extra records like:
--      AwsAttributes.Instance.PrivateIp x
--      AwsAttributes.Text.Instance.PrivateIp x
--      AwsAttributes.Bool.Instance.AssociatePublicIpAddress
--


--
-- In Terraform attributes provide 'delayed' values that become availible as
-- the resource graph is traversed and a resource is created.
-- We currently only support attributes of the following types:
--    Text
--    Natural
--    Boolean
--
-- Attributes can be used when defining resources, which implies a dependency.
-- Note recursive resource dependencies are *not* allowed, the resource graph
-- must be a DAG.
--
-- You can pass an arbirary number of attributes to a server or container
-- configuration expression. They types must correspond, e.g.
--
--    { config = \(x : Text) -> \(y : Optional Text) -> ...
--    , attributes = [someTextAttr, someOptionalAttr...]
--    ... }
--
let
AwsAttribute =
  -- TODO all these Texts refer to the TF resource name...
  < S3BucketId : Text -- { name : Text }
  | S3BucketRegion : Text -- { name : Text }
  | AwsInstancePrivateIp : Text -- { name : Text }
  | AwsIAMUserARN : Text
  | AwsIAMUserUniqueId : Text
  >
in

--
-- Returns the Dhall type of the given AwsAttribute
--
let
typeOf = \(x : AwsAttribute) ->
  merge
  { S3BucketId = \(_:Text) -> "Text"
  , S3BucketRegion = \(_:Text) -> "Text"
  , AwsInstancePrivateIp = \(_:Text) -> "Text"
  , AwsIAMUserARN = \(_:Text) -> "Text"
  , AwsIAMUserUniqueId = \(_:Text) -> "Text"
  }
  x : Text
in

let
AwsAttributes = constructors AwsAttribute
in


let
CannedACL =
	< Private : {}
	| PublicRead : {}
	| PublicReadWrite : {}
	-- TODO ...
	>
in

let
VersioningOptions = { mfaDelete : Bool }
in

let
S3BucketR =
  { resourceName : Text
  , bucketName : Optional Text
  , acl : Optional CannedACL
	, versioning : Optional VersioningOptions
  }
in

let
Blob = List Natural -- All values >255 are normalized as 0
in

let
S3BucketObjectSource =
  < Utf8 : Text -- TODO what is Dhall text?
                -- Following dhall-haskell it is Data.Text.Text, which has a canonical binary representation (UTF8)
                -- We should use that!
  | Binary : Blob
  >
in

let
S3BucketObjectR =
  { bucketName : Text
  , key : Text
  , source : S3BucketObjectSource
  }
in

-- TODO static website example using S3 bucket w. PublicRead

-- Const functor
let
Const = \(a : Type) -> \(b : Type) -> a
in

-- How to configure an AWS instance

-- For now
-- 1) We only support launhing NixOS instances
-- 2) This must be a valid Dhall expression that compiles to a valid NixOS config
let
AwsInstanceConfig = Text
in


let
Attr = Const Text
in

let
AwsInstanceR =
  -- Affects name of instance
  -- You must create a ServerConfig (Nix expression) of the same name
  { name : Text
  -- Config expression
  -- Must be Dhall function of type (A -> B) where A is the type corresponding
  -- to the value of configAttrs and B is a valid Nix expression.

  , config : Coyoneda Attr Text -- (Attr b, b -> Text)
  -- Attributes to pass to the configuration
  , configAttrs : List AwsAttribute
  -- Generate a set of static files (subpaths of /var/static)
  , staticFiles : List { path : Text, content : Text }
  }
in

let
AwsIAMUserR =
  { name : Text
  }
in

-- AWS IAM Group
-- In TF this generates both the aws_iam_group and aws_iam_group_membership resources.
let
AwsIAMGroupR =
  { name : Text
  , members : List AwsIAMUserR
  }
in

let
AwsIAMRoleR =
  { assumeRolePolicy : Text
  }
in

let
AwsIAMPolicyR =
  { arn : Text
  }
in

let
AwsResource =
  < AwsInstance : AwsInstanceR
  | S3Bucket : S3BucketR
  | S3BucketObject : S3BucketObjectR

  | AwsIAMUser : AwsIAMUserR
  | AwsIAMGroup : AwsIAMGroupR
  | AwsIAMRole : AwsIAMRoleR
  | AwsIAMPolicy : AwsIAMPolicyR
  >
in
let
AwsResources = constructors AwsResource
in

let
foldMap =
  \(a : Type) ->
  \(xs : List a) ->
  \(r : Type) ->
  \(m :
    { empty : r
    , single : a -> r
    , compose : r -> r -> r
    } ) ->
  -- List/fold (m.compose . m.single) m.empty
  List/fold a xs r (\(x : a) -> m.compose (m.single x)) m.empty
  : r
in

let
concatMapSepBy =
  \(pre : Text) ->
  \(end : Text) ->
  \(delim : Text) ->
  \(a : Type) ->
  \(show : a -> Text) ->
  \(xs : List a) ->
    let inner =
    foldMap a xs Text
    { empty = ""
    , single = show
    , compose = \(x : Text) -> \(y : Text) -> x ++ delim ++ y
    }
    in pre ++ inner ++ end
  : Text
in
"TODO"

-- TODO make use of the following Kubernetes networking notes
--    A kub cluster is a set of machines on a private network running nodes (controllers and workers). Each worker maintains a collection of pods (sets of containers with shared networking/disk, basically virtual computers with a set of services).
--
--    In any private k8s network you have IPs for nodes ('actual' machines), Pods and Services (faked, using iptables).
--    To expose them externally, use NodePort/LoadBalancer/Ingress

-- TODO do more: https://www.whizlabs.com/
--  Esp. the security certificates

-- TODO FIXME If provisioner fails, EC2 instances are not tainted in TF (presumably because only the fake
-- null resource we generate actually fails to provision - those were added to ensure the Nix config is
-- always repushed when it has changed - alternative way of doing that?).
-- NOTE this is only a problem if the provisioner *breaks* the instance, e.g. by filling the harddrive

-- TODO IAM group/role/policy (e.g. create S3 bucket and give access to single instance)

-- TODO NOW S3 bucket creation/addition

-- TODO redis cluster (either ElastiCache or EC2+NixOS)

-- TODO RDS instance + user + database

-- TODO setup custom VPC with private subnet?

-- TODO test AWS SNS?

-- TODO NOW extend Docker/NixOS/EC2 to build a static set of containers
-- Push results to ECS (for now)
-- Extend testDocker to also install Packer+Terraform, build images, and push to ECS
--      pkgs.packer
--      pkgs.terraform

-- TODO Gitlab + Pipeline that builds docker images (isolated from Internet to assure pure functin of commit)
--  + orchestration in k8s/EKS or Nomad/NixOS/EC2


-- TODO get TF to boot EKS cluster and run standard containers in there (e.g. consul cluster)

-- TODO NixOS machine with docker + standard consul image
-- E.g. as above, then run:
-- 		docker pull consul
-- 		docker run -t -i consul agent -bootstrap-expect=1 -server


-- TODO build custom Docker images using NixOS (preferably driven by expressions, similar to our NixOS provisioning)
--   See: https://nixos.wiki/wiki/Docker

-- TODO Consul cluster based on Docker+Kubernetes?
-- TODO more generally: config/launch containers in EKS, or functions in Lambda as an alternative to NixOS/EC2

-- TODO use packer to build AMIs/Docker containers

-- TODO [NOTE pinNixPkgs] pin nixpkgs on the machines/AMI?
-- See:
--    http://www.haskellforall.com/2018/08/nixos-in-production.html

-- TODO configurable EC2 instance type/size

-- TODO something like
--    https://itnext.io/building-a-kubernetes-hybrid-cloud-with-terraform-fe15164b35fb


--
-- TODO simple test suite
-- Should take
--    [{norosExpr:Text,expectedEndpoint:Text,timeout:Natural}]
-- deploys a bunch of expressions in sequence and verifies the
-- given URL comes up within the given time.
-- Note some 'test' fields sketched above.
