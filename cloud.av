
-- FOO
--
      -- BAR
let concatMap = ./vendor/dhall-lang/Prelude/Text/concatMap
let
generate = ./vendor/dhall-lang/Prelude/List/generate
let
Functor = ./vendor/dhall-bhat/Functor/Type
let
List_functor = ./vendor/dhall-bhat/List/functor
let
Applicative = ./vendor/dhall-bhat/Applicative/Type
let
liftA2 = ./vendor/dhall-bhat/Applicative/liftA2
let Coyoneda = ./vendor/dhall-bhat/Coyoneda/Type
let
liftCoyoneda = ./vendor/dhall-bhat/Coyoneda/lift
let
mapCoyoneda = \(f : Type -> Type) -> (./vendor/dhall-bhat/Coyoneda/functor f).map
let T = Type
let TT = Type -> Type
-- Free objects of kind (Type -> Type) using final encoding
let
Free1 = \(class : TT -> T) -> \(f:TT) -> \(a:T) ->
  forall (g:TT) -> class g -> (forall (x:T) -> f x -> g x) -> g a
let
FreeAp = Free1 Applicative
let
FreeAp_functor
  : forall (f : TT) -> Functor (FreeAp f)
  = \(ff : TT) ->
    { map =
         \(a : T)
      -> \(b : T)
      -> \(f : a -> b)
      -> \(g : FreeAp ff a)
      ->
        ((  \(gg : TT)
        -> \(ggAp : Applicative gg)
        -> \(k : forall (x:T) -> ff x -> gg x)
        -> ggAp.map a b f (g gg ggAp k)
        ): FreeAp ff b
        )
    }
let
FreeAp_applicative
  : forall (f : TT) -> Applicative (FreeAp f)
  = \(ff : TT) ->
    { pure =  λ(a : Type) → λ(x : a) →
      (( \(gg : TT)
      -> \(ggAp : Applicative gg)
      -> \(k_ : forall (x:T) -> ff x -> gg x)
      -> ggAp.pure a x
      ) : FreeAp ff a)
    , ap =
        \(a:T)
      ->\(b:T)
      ->\(f:FreeAp ff (a -> b))
      ->\(x:FreeAp ff a)
      -> ( \(gg:TT)
         ->\(ggAp : Applicative gg)
         ->\(k : forall (x:T) -> ff x -> gg x)
         -> ggAp.ap a b (f gg ggAp k) (x gg ggAp k)
         )
    } /\ FreeAp_functor ff
let
liftFreeAp
  : forall (f : TT) -> forall (a : T) -> f a -> FreeAp f a
  =   \(f:TT)
    ->\(a:T)
    ->\(x:f a)
    ->( \(g:TT)
      ->\(gAp:Applicative g)
      ->\(k : forall (x:T) -> f x -> g x)
      -> k a x)
let
retractFreeAp
  : forall (f : TT)
  -> forall (a : T)
  -> forall (ap : Applicative f)
  -> forall (fAp : FreeAp f a)
  -> f a
  = \(f:TT) -> \(a:T) ->
  let id = \(b:T) -> \(x : f b) -> x in
  \(ap:Applicative f) -> \(fAp:FreeAp f a) ->
    fAp f ap id : f a
-- Terraform providers used by the code we generate
-- Hardcoded for now
let
standardProviders =
  ''
  provider "aws" {
    region  = "eu-west-1"
    version = "= 1.54.0"
    profile = "default"
  }
  provider "null" {
    version = "= 1.0"
  }
  provider "external" {
    version = "= 1.0.0"
  }
  provider "random" {
    version = "= 2.0.0"
  }
  ''
-- Standard AWS options
-- Hardcoded for now
-- ami:
--  AMI from https://nixos.org/nixos/download.html
--  Note that these are AZ/region-specific
--  Nixos 18.09
let
standardAwsOptions =
  { ami = "ami-0f412186fb8a0ec97"
  , instanceType = "t2.micro"
  , keyName = "admin"
  , publicKeyFile = "~/.ssh/id_rsa.pub"
  , privateKeyFile = "~/.ssh/id_rsa"
  , rootBlockDeviceVolumeSize = { gigabytes = 30 }
  }

-- Standard NixOS preamble
-- Hardcoded for now
let nixPre =
  ''
  { config, pkgs, ... }:
  {
    imports = [ <nixpkgs/nixos/modules/virtualisation/amazon-image.nix> ];
    ec2.hvm = true;
  }
  //
  ''




--
-- AWS
--
-- TODO flatten for easier construction
-- Could also provide extra records like:
--      AwsAttributes.Instance.PrivateIp x
--      AwsAttributes.Text.Instance.PrivateIp x
--      AwsAttributes.Bool.Instance.AssociatePublicIpAddress
--


--
-- In Terraform attributes provide 'delayed' values that become availible as
-- the resource graph is traversed and a resource is created.
-- We currently only support attributes of the following types:
--    Text
--    Natural
--    Boolean
--
-- Attributes can be used when defining resources, which implies a dependency.
-- Note recursive resource dependencies are *not* allowed, the resource graph
-- must be a DAG.
--
-- You can pass an arbirary number of attributes to a server or container
-- configuration expression. They types must correspond, e.g.
--
--    { config = \(x : Text) -> \(y : Optional Text) -> ...
--    , attributes = [someTextAttr, someOptionalAttr...]
--    ... }
--
-- TODO all these Texts refer to the TF resource name...
let
AwsAttribute : Type =
  < S3BucketId : Text -- { name : Text }
  | S3BucketRegion : Text -- { name : Text }
  | AwsInstancePrivateIp : Text -- { name : Text }
  | AwsIAMUserARN : Text
  | AwsIAMUserUniqueId : Text
  >

--
-- Returns the Dhall type of the given AwsAttribute
--
let
typeOf = \(x : AwsAttribute) ->
  merge
  { S3BucketId = \(_:Text) -> "Text"
  , S3BucketRegion = \(_:Text) -> "Text"
  , AwsInstancePrivateIp = \(_:Text) -> "Text"
  , AwsIAMUserARN = \(_:Text) -> "Text"
  , AwsIAMUserUniqueId = \(_:Text) -> "Text"
  }
  x : Text
let
CannedACL =
  < Private : {}
  | PublicRead : {}
  | PublicReadWrite : {}
  >

let
VersioningOptions = { mfaDelete : Bool }

let
S3BucketR =
  { resourceName : Text
  , bucketName : Optional Text
  , acl : Optional CannedACL
  , versioning : Optional VersioningOptions
  }

-- TODO All values >255 are normalized as 0
let
Blob = List Natural

let
S3BucketObjectSource =
  < Utf8 : Text -- TODO what is Dhall text?
                -- Following dhall-haskell it is Data.Text.Text, which has a canonical binary representation (UTF8)
                -- We should use that!
  | Binary : Blob
  >

let
S3BucketObjectR =
  { bucketName : Text
  , key : Text
  , source : S3BucketObjectSource
  }


let Monoid = ./vendor/dhall-bhat/Monoid/Type

-- Const functor
let
Const = \(a : Type) -> \(b : Type) -> a
let Const_functor = \(x:Type) ->
  { map =
    \(a:T)
      -> \(b:T)
      -> \(f:a -> b)
      -> \(c:Const x a) -> c
  } : Functor (Const x)
let Const_applicative = \(m:Type) -> \(mon:Monoid m) ->
  ({ pure = \(a:T) -> \(x:a) -> mon.unit
  , ap =
    \(a:T)
    -> \(b:T)
    -> \(cf : Const m (a -> b))
    -> \(cx : Const m a)
    -> mon.op cf cx
  } /\ Const_functor m
  )
  : Applicative (Const m)

-- How to configure an AWS instance
--
-- For now
-- 1) We only support launhing NixOS instances
-- 2) This must be a valid Dhall expression that compiles to a valid NixOS config
let
AwsInstanceConfig = Text



--
-- NOTE [Safe attributes]
--
-- Functions like unsafeTextAttr assume that the given string represents a valid attribute
-- of the given type (e.g. Text in the case of unsafeTextAttr). The user should not be allowed
-- to specify this.
--
-- We could solve this by fake-GADTS, by making the library a function of (attr : Type -> Type)
-- and a record {fooAttr : attr Text, barAttr : attr Natural}
--
-- Full example
--
--    let
--      Id = \(a : Type) → a
--    in let
--      Const = \(a : Type) → \(b : Type) → a
--    in
--
--    (\(f:Type -> Type) ->
--     \(attrs : { foo : f Natural, bar : f Text }) ->
--     attrs.bar
--    )
--    (Const Text)
--    {foo = "fooAttr", bar = "barAttr"}
--


-- NOTE [PrimAttrs]
-- A "unityped" set of Terraform return values.
--
-- This type is part of the [Evaluator Protocol], see that note.
let
PrimAttr = <N:Natural | T:Text>

-- An attribute
--  * attrName is a valid TF splice expression, e.g. foo.bar
--  * attrType is one of the supported Dhall types, currently one of
--    - Natural
--    - Text
--  * attrParse is a parser that extracts a Dhall value of type attrType
let
AttrF = \(a:Type) -> {attrName:Text, attrType:Text, attrParse:PrimAttr -> Optional a}

let
toNix = \(x:Text) -> { nixExpr = nixPre ++ x }
let
toNixShow = \(x:Natural) -> toNix (Natural/show x)
let
Attr = FreeAp AttrF
let
mapAttr = (FreeAp_functor AttrF).map
let
liftA2Attr
  :   ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → (a → b → c)
    → Attr a
    → Attr b
    → Attr c
  = liftA2 Attr (FreeAp_applicative AttrF)
let
id = \(a:Type) -> \(x:a) -> x
let
someT
  : PrimAttr -> Optional Text
  = \(x:PrimAttr) ->
  merge
    { T = \(x:Text) -> Some x
    , N = \(x:Natural) -> (None Text)
    }
    x
-- See NOTE [Safe attributes]

let unsafeTextAttr = \(name:Text) ->
  liftFreeAp AttrF Text
    { attrName = name
    , attrType = "Text"
    , attrParse = \(x:PrimAttr) ->
      merge
        { T = \(x:Text) -> Some x
        , N = \(x:Natural) -> (None Text)
        }
        x
    }
let
someAttr
  = unsafeTextAttr  "thisAttrReturnsText"
  : Attr Text
-- See NOTE [Safe attributes]
let unsafeNatAttr = \(name:Text) ->
  liftFreeAp AttrF Natural
    { attrName = name
    , attrType = "Natural"
    , attrParse = \(x:PrimAttr) ->
      merge
        { N = \(x:Natural) -> Some x
        , T = \(x:Text) -> (None Natural)
        }
        x
    }
let
someNatAttr
  = unsafeNatAttr  "thisAttrReturnsNat"
  : Attr Natural


-- TODO
-- This types represents (exactly) the properties of a runnable node (container, EC2 instance, etc)
--
-- For now, all nodes are NixOS based, and Conf is an expression in the Nix config language, suitable
-- for dropping in /etc/nixos/configuration.nix
let
NodeConf = {nixExpr:Text}

let
AwsInstanceR =
  -- Affects name of instance
  { name : Text

  , config : Attr NodeConf

  -- Attributes to pass to the configuration
  -- , configAttrs : List AwsAttribute
  -- Generate a set of static files (subpaths of /var/static)
  , staticFiles : List { path : Text, content : Text }
  }

let
AwsIAMUserR =
  { name : Text
  }

-- AWS IAM Group
-- In TF this generates both the aws_iam_group and aws_iam_group_membership resources.
let
AwsIAMGroupR =
  { name : Text
  , members : List AwsIAMUserR
  }

let
AwsIAMRoleR =
  { assumeRolePolicy : Text
  }

let
AwsIAMPolicyR =
  { arn : Text
  }

let AwsSubnetR =
  { vpcId : Text
  , cidrBlock : Text
  }

let AwsEKSClusterR =
  { name : Text
  , roleArn : Text
  , vpcConfig : { subnetIds : List Text }
  }

-- min/max inclusive
let RandomIntegerR =
  { name : Text
  , min : Natural -- Inclusive
  , max: Natural -- Inclusive
  , seed : Optional Natural
  }

let RandomStringR =
  { name : Text
  , length : Natural
  }

-- TODO not all of these are AWS resources, move to separate type...
-- NOTE [Source vs Data] We're not distinguishing resource/data_source a la Terraform
-- Convention is: All TF data sources are suffixed with 'Data'

let
AwsResource =
  < AwsInstance : AwsInstanceR
  | S3Bucket : S3BucketR
  | S3BucketObject : S3BucketObjectR

  | AwsIAMUser : AwsIAMUserR
  | AwsIAMGroup : AwsIAMGroupR
  | AwsIAMRole : AwsIAMRoleR
  | AwsIAMPolicy : AwsIAMPolicyR

  | AwsSubnet : AwsSubnetR
  | AwsEKSCluster : AwsEKSClusterR

  | RandomInteger : RandomIntegerR
  | RandomString : RandomStringR
  >

let
foldMap =
  \(a : Type) ->
  \(xs : List a) ->
  \(r : Type) ->
  \(m :
    { empty : r
    , single : a -> r
    , compose : r -> r -> r
    } ) ->
  List/fold a xs r (\(x : a) -> m.compose (m.single x)) m.empty
  : r

let
concatMapSepBy =
  \(pre : Text) ->
  \(end : Text) ->
  \(delim : Text) ->
  \(a : Type) ->
  \(show : a -> Text) ->
  \(xs : List a) ->
    let inner =
    foldMap a xs Text
    { empty = ""
    , single = show
    , compose = \(x : Text) -> \(y : Text) -> x ++ delim ++ y
    }
    in pre ++ inner ++ end
  : Text

let
noFiles = [] : List {content:Text,path:Text}


--
-- NOTE currently NodeConf is Text, so the above also works with virtualization (e.g. for AMI/Docker,
-- create a packer script starting from a base image and provisioning with the Nix expression).
-- If NodeConf is changed to a *function*, the evaluator will use some Dhall backend to convert
-- this to a runnable image. This could work in several ways:
--    Blob -> Blob                 Become a (pure) web server
--    Blob -> State Blob Blob      Become a web server with (transient) state, backed by its own harddrive
--    Blob -> NodeConf             Wait for a web request, then *become* the given config
--    Blob -> Map Text NodeConf    Wait for a web request, then *launch new nodes* with the given config
--    A -> B                       Become a processor in a typed channel
--
--
-- TODO LATER special resources for cached provisions (AMIs/containers)
-- AMI-based, implemented by running packer on host machine:
--  * Resource a la AwsInstance that builds the NodeConf to an AMI and returns registered AMI
--  * Resource a la AwsInstance that takes such an AMI instead of a NodeConf
--
--
--
-- Implementation
--   Make name depend of TF config (including Nix expr) - reuse if exists in AWS account
--   Use external data source to call packer (with HS wrapper?)
--     Generates suitable JSON for packer and calls this
--       https://www.packer.io/docs/builders/amazon-ebs.html
--   Provide output attribute with the new AMI name
--   Provide this as an alternative input to AwsInstance

-- Docker-based, implemented by running docker+packer on a special instance:
--  * Resource a la AwsInstance that builds a NodeConf to a Docker container placed in ECR
--  * Resource that launches containers in EKS
--
--
--



--
-- TODO
--
-- Break recursive dependency between attrs/resources (using limited fixpoints?) to define safe
-- mappings between resources/attrs (e.g. prevent looking up an attr of resource of type A from
-- resource of type B).
--
-- Or use something like the NOTE [Safe attributes] approach, hiding the Attr constructors and
-- passing in a safe subset at the top level.



-- NOTE  [Evaluator Protocol]
--
-- The following types definne a protocol between the Dhall code and the
-- Terraform evaluator. The basic path is:
--
--  * EvaluatorInput generates a static graph passed to Terraform, except for
--  the tfContinue field, which is *normalized but not reduced to a
--  serializable type*
--
--  * For each node in the graph, we generates a special external_resource to
--  recieve inputs.  These are converted to PrimAttr, applied to the tfContinue
--  expression and *normalized as before*.
--
--  * The resultant NodeConf expression is handled by the evaluator. For a
--  NixOS config, the node is created and provisioned with the given
--  expression.
--
-- Static Inputs
-- ===
-- We allow 'static' inputs, e.g. inputs that have no dependencies in the TF
-- resource graph. The Haskell evaluator treats any EvaluatorInput where attrNames = []
-- as static. In this case the tfContinue value is ignored.
--
-- Abstraction & Interface
-- ====
--
-- Anything involving the evaluator protocol should be hidden from the user.
-- The main interface should be: user writes an expression of type (List
-- AwsResource), (List KubernetesResource) and so on for each backend.
--
-- Any changes to the Evaluator Protocol must be kept in sync between Dhall and
-- Haskell/CLI. Search for references to this note to find the relevant code
-- paths.

-- tfCodeBefore
--  Terraform code before the tfContinue block
-- tfCodeAfter
--  Terraform code after the tfCodeAfter block
-- tfContinue
   -- Spliced attributes and continuation
   --
   -- TODO returning NodeConf here implies that TF attributes other than 'uploaded config'
   -- can not depend on Attr values. We could enrich the return type here to include more
   -- such data if needed.

let EvaluatorInput =
   { tfCodeBefore : Text
   , tfCodeAfter : Text
   , attrNames: List Text
   , tfContinue: List PrimAttr -> Optional NodeConf
   }

let staticInput
  : Text -> EvaluatorInput
  = \(x : Text) -> { tfCodeBefore = x, tfCodeAfter = "", attrNames = [] : List Text, tfContinue = \(x:List PrimAttr) -> None NodeConf }

let Optional_monad = ./vendor/dhall-bhat/Optional/monad
let Optional_functor = ./vendor/dhall-bhat/Optional/functor
let StateT = ./vendor/dhall-bhat/StateT/Type
let StateT_applicative = ./vendor/dhall-bhat/StateT/applicative
  (List PrimAttr) Optional Optional_monad
let indexed = ./vendor/dhall-lang/Prelude/List/indexed
let filter = ./vendor/dhall-lang/Prelude/List/filter
let map = ./vendor/dhall-lang/Prelude/List/map
let not = ./vendor/dhall-lang/Prelude/Bool/not
let isZero = ./vendor/dhall-lang/Prelude/Natural/isZero
-- TODO use better tail
let uncons
  : ∀(a : Type) → List a → ∀(list : Type) → ∀(cons : a → List a → list) → ∀(nil : list) → list
  = \(a:T)
    -> let tail
        : List a -> List a
        = \(xs:List a) ->
          map {value:a,index:Natural} a (\(x:{value:a,index:Natural}) -> x.value)
            (filter {value:a,index:Natural} (\(x:{value:a,index:Natural}) ->
              not (isZero x.index))
              (indexed a xs))
        in
       \(xs:List a)
    -> \(r:T)
    -> \(cons: a → List a → r)
    -> \(nil:r)
    -> List/fold a xs r (\(x:a) -> \(cs:r) -> cons x (tail xs)) nil

let attrParserToState
  : forall (a : Type) -> AttrF a -> StateT (List PrimAttr) Optional a
  =    \(a:T)
    -> \(attr:AttrF a)
    -> ( \(s:List PrimAttr)
       ->
        uncons PrimAttr s (Optional{val:a,state:List PrimAttr})
        (    \(x:PrimAttr)
          -> \(xs:List PrimAttr)
          ->
          Optional/fold a (attr.attrParse x) (Optional{val:a,state:List PrimAttr})
            (\(x:a) -> Some {val=x,state=xs})
            (None {val:a,state:List PrimAttr} )
        )
        (None {val:a,state:List PrimAttr})
       )


-- forall (g:TT) -> Applicative g -> (forall (x:T) -> f x -> g x) -> g a
let runAttr
  : Attr NodeConf -> List PrimAttr -> Optional NodeConf
  = \(attr : Attr NodeConf) -> \(inputs : List PrimAttr) ->
    let Res = {val:NodeConf,state:List PrimAttr}
    let parser
      : StateT (List PrimAttr) Optional NodeConf
      = attr
        (StateT (List PrimAttr) Optional)
        StateT_applicative
        attrParserToState
    in
      Optional_functor.map
        Res
        NodeConf
        (\(x:Res) -> x.val)
        (parser inputs)

let Text_monoid = { unit = "", op = \(x:Text) -> \(y:Text) -> x ++ y } : Monoid Text
let List_monoid = ./vendor/dhall-bhat/List/monoid

let getAttrTypes
  : Attr NodeConf -> List Text
  = let attrParserToConst
    : forall (a : Type) -> AttrF a -> Const (List Text) a
    = \(a : T)
      -> \(attr : AttrF a)
      -> [attr.attrType]
  in
  \(attr : Attr NodeConf) ->
    let r
      : Const (List Text) NodeConf
      = attr
        (Const (List Text))
        (Const_applicative (List Text) (List_monoid Text))
        attrParserToConst
    in r

let getAttrNames
  : Attr NodeConf -> List Text
  = let attrParserToConst
    : forall (a : Type) -> AttrF a -> Const (List Text) a
    = \(a : T)
      -> \(attr : AttrF a)
      -> [attr.attrName]
  in
  \(attr : Attr NodeConf) ->
    let r
      : Const (List Text) NodeConf
      = attr
        (Const (List Text))
        (Const_applicative (List Text) (List_monoid Text))
        attrParserToConst
    in r

let id = \(a : Type) -> \(x : a) -> x


    -- TODO chose a random limit string?
    -- TODO allow static files again?
    -- TODO FIXME unescaped attr names may cause problems

let awsInstanceToInput
  : AwsInstanceR -> EvaluatorInput
  = \(instance : AwsInstanceR) ->
    let name = instance.name
    let staticFileBlock = ""
    let wrapAttr = \(x : Text) -> "\"\${" ++ x ++ "}\""
    let attrTypeBlock =
      ''
      "${./vendor/dhall-lang/Prelude/Text/concatMapSep ", " Text (id Text) (getAttrTypes instance.config)}"
      ''
    let attrBlock =
      ''
      ${./vendor/dhall-lang/Prelude/Text/concatMapSep ", " Text wrapAttr (getAttrNames instance.config)}
      ''
    in
    { tfCodeBefore =
    ''
          data "external" "${name}-eval" {
            program =
              [ "./bin/eval"
              , ${attrTypeBlock}
              , <<END_AHJSHDJALKASJDHKJHVHJHEJKBAB
    ''
    , tfCodeAfter =
    ''
              END_AHJSHDJALKASJDHKJHVHJHEJKBAB
              , ${attrBlock}
              ]
            query =
              {
              }
          }
          // TODO do not duplicate the key pair/security group blocks
          // TODO more restrictive ingress by default
          resource "aws_key_pair" "${standardAwsOptions.keyName}" {
            key_name   = "${standardAwsOptions.keyName}"
            public_key = "''${file("${standardAwsOptions.publicKeyFile}")}"
          }
          resource "aws_security_group" "standard" {
            name        = "standard"
            description = "Allow inbound HTTP and SSH + all outbound"

            ingress {
              from_port   = 22
              to_port     = 22
              protocol    = "tcp"
              cidr_blocks = ["0.0.0.0/0"]
            }
            ingress {
              from_port   = 80
              to_port     = 80
              protocol    = "tcp"
              cidr_blocks = ["0.0.0.0/0"]
            }

            egress {
              from_port       = 0
              to_port         = 0
              protocol        = "-1"
              cidr_blocks     = ["0.0.0.0/0"]
            }
          }

          resource "aws_instance" "${name}" {
            ami             = "${standardAwsOptions.ami}"
            instance_type   = "${standardAwsOptions.instanceType}"
            key_name        = "${standardAwsOptions.keyName}"
            security_groups = ["standard"]

            tags {
              Name = "${name}"
            }

            root_block_device {
              volume_size = ${Natural/show standardAwsOptions.rootBlockDeviceVolumeSize.gigabytes}
            }
          }
          resource "null_resource" "${name}-prov" {
            triggers {
              build_number = "''${timestamp()}"
            }
            connection {
              type = "ssh"
              user = "root"
              host = "''${element(aws_instance.${name}.*.public_ip, 0)}"
              private_key = "''${file("${standardAwsOptions.privateKeyFile}")}"
            }
            provisioner "file" {
              content = "''${data.external.${name}-eval.result.nix}"
              destination = "/etc/nixos/configuration.nix"
            }
            provisioner "remote-exec" {
              inline = [
                "mkdir -p /var/static"
              ]
            }
            ${staticFileBlock}
            provisioner "remote-exec" {
              inline = [
                "echo *** Start of /etc/nixos/construction.nix ***",
                "cat /etc/nixos/configuration.nix",
                "echo",
                "echo *** End of /etc/nixos/construction.nix ***",

                "nixos-rebuild switch"
              ]
            }
          }

    ''

    , attrNames = getAttrNames instance.config
    , tfContinue = runAttr instance.config
    }

let pureAttr = (FreeAp_applicative AttrF).pure

let maybeToList
  : forall (a : Type) -> Optional a -> List a
  = \(a : Type) ->
    \(x : Optional a) ->
    Optional/fold a x (List a) (\(y : a) -> [y]) ([] : List a)

let catMaybes
  : forall (a : Type) -> List (Optional a) -> List a
  = \(a : Type) ->
    ./vendor/dhall-lang/Prelude/List/concatMap (Optional a) a (maybeToList a)

-- Convert a resource to an input
-- TODO the Optional wrapper is just a debugging tool, should be removed
    -- TODO
    -- * Make test suite for RandomInteger, RandomString
    -- TODO support all AwsResource properly
      -- TODO split up the EKS block...
      -- TODO replace all count.index etc below with Dhall normalization...
      -- TODO instead of whitelisting access to API server below, fall back
      --  on standard AV access rules (e.g. AWS/GCE credentials). For dev/default
      --  we can leave this open *assuming* Kubernetes TLS certificates is enough
      --  to protect the API server (TODO check this!).
-- TODO after deploying an EKS cluster we have to run this to setup node auth:
-- Automate?
--    terraform output eks-clusters.fruktsallad-auth | bin/askvader kubectl fruktsallad apply -f -
let resourceToInput
  : AwsResource -> Optional EvaluatorInput
  = \(x : AwsResource) ->
  merge
    { AwsInstance = \(x : AwsInstanceR) -> Some (awsInstanceToInput x)
    , RandomInteger = \(x : RandomIntegerR) -> Some (staticInput
      ''
      resource "random_integer" "${x.name}" {
        min     = ${Natural/show x.min}
        max     = ${Natural/show x.max}
        ${Optional/fold Natural x.seed Text (Natural/show) ""}
      }
      '')
    , RandomString = \(x : RandomStringR) -> Some (staticInput
      ''
      resource "random_string" "${x.name}" {
        length     = ${Natural/show x.length}
      }
      '')

    , S3Bucket = \(x : S3BucketR) -> None EvaluatorInput
    , S3BucketObject = \(x : S3BucketObjectR) -> None EvaluatorInput
    , AwsIAMUser = \(x : AwsIAMUserR) -> None EvaluatorInput
    , AwsIAMGroup = \(x : AwsIAMGroupR) -> None EvaluatorInput
    , AwsIAMRole = \(x : AwsIAMRoleR) -> None EvaluatorInput
    , AwsIAMPolicy = \(x : AwsIAMPolicyR) -> None EvaluatorInput

    , AwsSubnet = \(x : AwsSubnetR) -> None EvaluatorInput
    , AwsEKSCluster = \(x : AwsEKSClusterR) ->
      let clusterName = "fruktsallad"
      in
      None EvaluatorInput
    }
    x


let foo = [1] # map Natural Natural (id Natural) [2]
in


-- Examples

{ run
  = \(xs : List AwsResource) ->
    [staticInput standardProviders] # catMaybes EvaluatorInput
      (map AwsResource (Optional EvaluatorInput)
        resourceToInput xs)
, test =

  [ AwsResource.RandomInteger { name = "foo", min = 1, max = 10, seed = None Natural }
  , AwsResource.RandomString { name = "bar", length = 5 }
  , AwsResource.AwsInstance
      { name = "x"
      , staticFiles = noFiles
      , config =
        let
          mkConf = \(x:Natural) -> \(y:Text) -> { nixExpr = nixPre ++ "{ # foo = " ++ Natural/show x ++
          "; bar = " ++ y ++ "; \n virtualisation.docker.enable = true; }" }
        in
          liftA2Attr Natural Text NodeConf mkConf
            --someAttr
            (unsafeNatAttr "random_integer.foo.result")
            (unsafeTextAttr "random_string.bar.result")
            --(mapAttr Natural Text Natural/show someNatAttr)
      }
  , AwsResource.AwsEKSCluster
     { name = "demo-cluster"
     , roleArn = "TODO-DUMMY-NOT-USED"
     , vpcConfig =
       { subnetIds = ["TODO-DUMMY"]
       }
     }
  ]
}



