#!/usr/bin/env runghc
-- vi:syntax=haskell
{-# LANGUAGE OverloadedStrings #-}

import Control.Applicative
import Text.ParserCombinators.ReadP
import System.Directory (createDirectoryIfMissing)
import System.Environment (getArgs)
import Control.Monad
import Data.List (nub, intercalate)

main = do
  print ()
  [inputPath, dir] <- getArgs
  input <- readFile inputPath
  let decl = runParser parseDecl input
  traverse print $ transitiveDeps decl
  render dir decl

runParser :: ReadP a -> String -> a
runParser p inp = fst . last . ($ inp) $ readP_to_S p


-- Subset of Dhall kinds for which we generate 'package...' files
data Kind = Term | Type --  | TypeToType
  deriving (Show, Eq)

showKind Nothing = ""
showKind (Just Term) = ""
showKind (Just Type) = ": Type"

-- A "declaration", generated by a single let-binding
data Decl = Decl
  { name :: String
  , kind :: (Maybe Kind) -- Nothing if not in the subset we care about, see Kind
  , body :: String
  , deps :: [Decl] -- previous declarations
  }
  deriving (Show, Eq)

-- Parse a file, return top level declaration (called 'main').
parseDecl :: ReadP Decl
-- TODO
parseDecl = pure $
  Decl "main" (Just Term)
  "-- This is main\nbar"
  [ Decl "bar" (Just Term)
    "-- This is bar \n foo + 1"
    [ Decl "foo" (Just Term)
      "1 : X"
      [ Decl "X" (Just Type)
        "Natural"
        []
      ]
    ]
  ]

-- Transitive deps of a decl, not including itself
transitiveDeps :: Decl -> [Decl]
transitiveDeps = init . nub . go
  where
    go d = (concatMap go $ deps d) ++ [d]

-- Create a package... record from the transitive deps of the given kind
-- TODO use transitiveDeps and filter...
importsRec :: Kind -> Decl -> String
importsRec kind decl = "-- TODO"

-- Generate a let binding importing the decl of a name
-- For all transitive dependencies of the given decl (but not itself!)
depImports :: Decl -> String
depImports d = intercalate "\n" $ fmap go $ transitiveDeps d
  where
    go decl = "let "++name decl++" "++showKind (kind decl)++" = ./" ++ name decl

render :: FilePath -> Decl -> IO ()
render path decl = do
  createDirectoryIfMissing True path
  let write name = writeFile (path ++ "/" ++ name) . (++ "\n")
  write (name decl)
    (depImports decl ++ (if null (depImports decl) then "" else "\nin") ++ "\n" ++ body decl)
  void $ traverse (render path) (deps decl)

  -- TODO write the top level package...
  writeFile (path ++ "/package") (importsRec Term decl)
  writeFile (path ++ "/packageTypes") (importsRec Type decl)

{- Utility for splitting big .av files containing let-expressions.

  split-file x.av dir/

will split the file x.av and place results in dir/, thus:

- File is split after each \n that is the END of the last line containing code (e.g. not just WS or comments)
  immediately preceding a line starting with 'let'.
- The binding "let foo : T = E" places "let foo : T = E in foo" in the output file "foo.av"
- Each file is prepended by one let-line for each preceding definition
- The last block is written to 'main'


Example: This

    let X = Natural
    let foo = 1 : X
    -- About bar
    let bar = foo + 1
    in bar

becomes

cat ./X
let X = Natural
in X

cat ./foo
let X = ./X
let foo = 1 : X
in foo

cat ./bar
let X = ./X
let foo = ./foo
-- About bar
let bar = foo + 1
in bar

cat ./main
...
let bar = ./bar
in bar

As a utility, record files called package... are created, one per kind. Specifically:
  ./package         All lowercase names.
  ./packageTypes    All uppercase names with an annotation 'Type', e.g. "let Foo : Type = ..."
  ./packageTypes1   As above, kind 'Type -> Type', etc

For the above example:

./package
in { foo = ./foo, bar = ./bar }

./packageTypes
let X = ./X
in { X = ./X }

TODO other kinds?
-}
