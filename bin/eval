#!/usr/bin/env runghc
-- vi:syntax=haskell
{-# LANGUAGE OverloadedStrings, ScopedTypeVariables #-}

import System.Environment
import System.Process
import Data.List (intercalate)
import qualified Data.Text as Text

import Dhall

main = do
  args <- getArgs

  writeFile "DEBUG" (show $ tail $ tail $ args)
  appendFile "DEBUG" (show $ head args)

  -- NOTE [Parsing Terraform inputs]
  -- It is not well documented how Terraform passes splice results to an external_resource.
  -- We'll find out as we go along and put the observations here.
  --
  -- Observations:
  --  * Numbers are passed as strings, e.g. a possible value for (fmap (!! 1) getArgs) is "2"
  --  * Text us passed as unquoted strings, e.g. a possible value for (fmap (!! 1) getArgs) is "h#@sj"

  let types = args !! 0
  -- TODO pass a string like "Natural, Text" etc
  let cont = args !! 1
  let params = tail $ tail args
  -- TODO generate these from params based on types
  let dhallParams = "([ <N=554433|T:Text>, <N:Natural|T=\"foo\">])"
  let fullCode = "(" ++ cont ++ ")" ++ dhallParams

  -- TODO improve error message if we fail here
  dhallExpr <- Text.pack <$> readProcess "dhall" ["normalize"] fullCode

  -- NOTE
  -- Currently this is always a (Some {nixExpr : Text})
  -- See NOTE [Evaluator Protocol]
  mNixExpr :: Maybe Text <- input (Dhall.maybe $ record $ field "nixExpr" strictText) dhallExpr
  case mNixExpr of
    Nothing -> error $ "eval: Attr parser failed"
    Just nixExpr ->
      -- Escape the nixExpr for JSON as per TF external resource protocol
      putStrLn $ "{\"nix\": " ++ show nixExpr ++ "}"

