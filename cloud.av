
let
concatMap = ./vendor/dhall-lang/Prelude/Text/concatMap
in
let
generate = ./vendor/dhall-lang/Prelude/List/generate
in

let
Functor = ./vendor/dhall-bhat/Functor/Type
in
let
Applicative = ./vendor/dhall-bhat/Applicative/Type
in
let
liftA2 = ./vendor/dhall-bhat/Applicative/liftA2
in

let
Coyoneda = ./vendor/dhall-bhat/Coyoneda/Type
in
let
liftCoyoneda = ./vendor/dhall-bhat/Coyoneda/lift
in
let
mapCoyoneda = \(f : Type -> Type) -> (./vendor/dhall-bhat/Coyoneda/functor f).map
in


-- Free Alternative (using final encoding)
let T = Type in
let TT = Type -> Type in
let
FreeAp = \(f:TT) -> \(a:T) ->
  forall (g:TT) -> Applicative g -> (forall (x:T) -> f x -> g x) -> g a

in
let
FreeAp_functor
  : forall (f : TT) -> Functor (FreeAp f)
  = \(ff : TT) ->
    { map =
         \(a : T)
      -> \(b : T)
      -> \(f : a -> b)
      -> \(g : FreeAp ff a)
      ->
        ((  \(gg : TT)
        -> \(ggAp : Applicative gg)
        -> \(k : forall (x:T) -> ff x -> gg x)
        -> ggAp.map a b f (g gg ggAp k)
        ): FreeAp ff b
        )
    }
in
let
FreeAp_applicative
  : forall (f : TT) -> Applicative (FreeAp f)
  = \(ff : TT) ->
    { pure =  λ(a : Type) → λ(x : a) →
      (( \(gg : TT)
      -> \(ggAp : Applicative gg)
      -> \(k_ : forall (x:T) -> ff x -> gg x)
      -> ggAp.pure a x
      ) : FreeAp ff a)
    , ap =
        \(a:T)
      ->\(b:T)
      ->\(f:FreeAp ff (a -> b))
      ->\(x:FreeAp ff a)
      -> ( \(gg:TT)
         ->\(ggAp : Applicative gg)
         ->\(k : forall (x:T) -> ff x -> gg x)
         -> ggAp.ap a b (f gg ggAp k) (x gg ggAp k)
         )
    } /\ FreeAp_functor ff
in
let
liftFreeAp
  : forall (f : TT) -> forall (a : T) -> f a -> FreeAp f a
  =   \(f:TT)
    ->\(a:T)
    ->\(x:f a)
    ->( \(g:TT)
      ->\(gAp:Applicative g)
      ->\(k : forall (x:T) -> f x -> g x)
      -> k a x)
in
let
retractFreeAp
  : forall (f : TT)
  -> forall (a : T)
  -> forall (ap : Applicative f)
  -> forall (fAp : FreeAp f a)
  -> f a
  = \(f:TT) -> \(a:T) ->
  let id = \(b:T) -> \(x : f b) -> x in
  \(ap:Applicative f) -> \(fAp:FreeAp f a) ->
    fAp f ap id : f a
in


-- Terraform providers used by the code we generate
-- Hardcoded for now
let
standardProviders =
  ''
  provider "aws" {
    region  = "eu-west-2"
    version = "= 1.54.0"
    profile = "dev"
  }
  provider "null" {
    version = "= 1.0"
  }
  provider "external" {
    version = "= 1.0.0"
  }
  ''
in

-- Standard AWS options
-- Hardcoded for now
let
standardAwsOptions =
  -- AMI from https://nixos.org/nixos/download.html
  -- Nixos 18.09
  { ami = "ami-0dada3805ce43c55e"
  , keyName = "admin"
	, instanceType = "t2.micro"
	-- , instanceType = "t2.medium"
  -- instance_type   = "m5d.2xlarge"
	-- , instanceType   = "t2.medium"
		-- instance_type = "i3.xlarge"
    --
  -- In GB
  , rootBlockDeviceVolumeSize = 30 -- TODO too big?
  }
in







--
-- AWS
--
-- TODO flatten for easier construction
-- Could also provide extra records like:
--      AwsAttributes.Instance.PrivateIp x
--      AwsAttributes.Text.Instance.PrivateIp x
--      AwsAttributes.Bool.Instance.AssociatePublicIpAddress
--


--
-- In Terraform attributes provide 'delayed' values that become availible as
-- the resource graph is traversed and a resource is created.
-- We currently only support attributes of the following types:
--    Text
--    Natural
--    Boolean
--
-- Attributes can be used when defining resources, which implies a dependency.
-- Note recursive resource dependencies are *not* allowed, the resource graph
-- must be a DAG.
--
-- You can pass an arbirary number of attributes to a server or container
-- configuration expression. They types must correspond, e.g.
--
--    { config = \(x : Text) -> \(y : Optional Text) -> ...
--    , attributes = [someTextAttr, someOptionalAttr...]
--    ... }
--
let
AwsAttribute =
  -- TODO all these Texts refer to the TF resource name...
  < S3BucketId : Text -- { name : Text }
  | S3BucketRegion : Text -- { name : Text }
  | AwsInstancePrivateIp : Text -- { name : Text }
  | AwsIAMUserARN : Text
  | AwsIAMUserUniqueId : Text
  >
in

--
-- Returns the Dhall type of the given AwsAttribute
--
let
typeOf = \(x : AwsAttribute) ->
  merge
  { S3BucketId = \(_:Text) -> "Text"
  , S3BucketRegion = \(_:Text) -> "Text"
  , AwsInstancePrivateIp = \(_:Text) -> "Text"
  , AwsIAMUserARN = \(_:Text) -> "Text"
  , AwsIAMUserUniqueId = \(_:Text) -> "Text"
  }
  x : Text
in

let
AwsAttributes = constructors AwsAttribute
in


let
CannedACL =
	< Private : {}
	| PublicRead : {}
	| PublicReadWrite : {}
	-- TODO ...
	>
in

let
VersioningOptions = { mfaDelete : Bool }
in

let
S3BucketR =
  { resourceName : Text
  , bucketName : Optional Text
  , acl : Optional CannedACL
	, versioning : Optional VersioningOptions
  }
in

let
Blob = List Natural -- All values >255 are normalized as 0
in

let
S3BucketObjectSource =
  < Utf8 : Text -- TODO what is Dhall text?
                -- Following dhall-haskell it is Data.Text.Text, which has a canonical binary representation (UTF8)
                -- We should use that!
  | Binary : Blob
  >
in

let
S3BucketObjectR =
  { bucketName : Text
  , key : Text
  , source : S3BucketObjectSource
  }
in

-- TODO static website example using S3 bucket w. PublicRead

-- Const functor
let
Const = \(a : Type) -> \(b : Type) -> a
in

-- How to configure an AWS instance
--
-- For now
-- 1) We only support launhing NixOS instances
-- 2) This must be a valid Dhall expression that compiles to a valid NixOS config
let
AwsInstanceConfig = Text
in



--
-- NOTE [Safe attributes]
--
-- Functions like unsafeTextAttr assume that the given string represents a valid attribute
-- of the given type (e.g. Text in the case of unsafeTextAttr). The user should not be allowed
-- to specify this.
--
-- We could solve this by fake-GADTS, by making the library a function of (attr : Type -> Type)
-- and a record {fooAttr : attr Text, barAttr : attr Natural}
--
-- Full example
--
--    let
--    	Id = \(a : Type) → a
--    in let
--    	Const = \(a : Type) → \(b : Type) → a
--    in
--
--    (\(f:Type -> Type) ->
--     \(attrs : { foo : f Natural, bar : f Text }) ->
--     attrs.bar
--    )
--    (Const Text)
--    {foo = "fooAttr", bar = "barAttr"}
--
-- TODO later
-- Because Text is not inspectable in Dhall, we can currently only parse Text attribtutes
-- Workaround: Accept a type of dynamic inputs: <Text|Natural...>
let
AttrF = \(a:Type) -> {attrName:Text,attrParse:Text -> a}
in

let
toNix = \(x:Text) -> { nixExpr = x }
in
let
toNix2 = \(x:Text) -> \(y:Text) -> { nixExpr = x ++ y }
in
let
toNixShow = \(x:Natural) -> toNix (Natural/show x)
in
let
-- TODO With Coyoneda, the config can only depend on a single outout
-- Switch to a free (finally encoded?) Applicative/Alternative to allow depending on multiple outputs
Attr = FreeAp AttrF
in
let
mapAttr = (FreeAp_functor AttrF).map
in
let
liftA2Attr
  :   ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → (a → b → c)
    → Attr a
    → Attr b
    → Attr c
  = liftA2 Attr (FreeAp_applicative AttrF)
in
let
id = \(a:Type) -> \(x:a) -> x
in
let
some = \(a:Type) -> \(x:a) -> Some x
in
let
-- See NOTE [Safe attributes]
unsafeTextAttr = \(name:Text) ->
  liftFreeAp AttrF Text {attrName=name,attrParse = id Text}
in
let
someAttr
  = unsafeTextAttr  "thisAttrReturnsText"
  : Attr Text
in

-- TODO
-- This types represents (exactly) the properties of a runnable node (container, EC2 instance, etc)
--
-- For now, all nodes are NixOS based, and Conf is an expression in the Nix config language, suitable
-- for dropping in /etc/nixos/configuration.nix
let
NodeConf = {nixExpr:Text}
in

let
AwsInstanceR =
  -- Affects name of instance
  { name : Text

  , config : Attr NodeConf

  -- Attributes to pass to the configuration
  -- , configAttrs : List AwsAttribute
  -- Generate a set of static files (subpaths of /var/static)
  , staticFiles : List { path : Text, content : Text }
  }
in

let
AwsIAMUserR =
  { name : Text
  }
in

-- AWS IAM Group
-- In TF this generates both the aws_iam_group and aws_iam_group_membership resources.
let
AwsIAMGroupR =
  { name : Text
  , members : List AwsIAMUserR
  }
in

let
AwsIAMRoleR =
  { assumeRolePolicy : Text
  }
in

let
AwsIAMPolicyR =
  { arn : Text
  }
in

let
AwsResource =
  < AwsInstance : AwsInstanceR
  | S3Bucket : S3BucketR
  | S3BucketObject : S3BucketObjectR

  | AwsIAMUser : AwsIAMUserR
  | AwsIAMGroup : AwsIAMGroupR
  | AwsIAMRole : AwsIAMRoleR
  | AwsIAMPolicy : AwsIAMPolicyR
  >
in
let
AwsResources = constructors AwsResource
in

let
foldMap =
  \(a : Type) ->
  \(xs : List a) ->
  \(r : Type) ->
  \(m :
    { empty : r
    , single : a -> r
    , compose : r -> r -> r
    } ) ->
  -- List/fold (m.compose . m.single) m.empty
  List/fold a xs r (\(x : a) -> m.compose (m.single x)) m.empty
  : r
in

let
concatMapSepBy =
  \(pre : Text) ->
  \(end : Text) ->
  \(delim : Text) ->
  \(a : Type) ->
  \(show : a -> Text) ->
  \(xs : List a) ->
    let inner =
    foldMap a xs Text
    { empty = ""
    , single = show
    , compose = \(x : Text) -> \(y : Text) -> x ++ delim ++ y
    }
    in pre ++ inner ++ end
  : Text
in

let
noFiles = [] : List {content:Text,path:Text}
in


{- TODO
 - Write a new evaluator (in Haskell?) that extracts config code and
 -  * Extracts functions of TF-generated attributes, writes them to eval fake-resources (as before)
 -  * Generates top level TF (by looking at the attrName in the free ap/coyoneda)
 -  * Invokes TF
 - Basically this is simple:
 - Given an AwsInstanceR r, we can extract the attribute and a parsing function using
 -
		⊢ r.config Text ( \(c:Type) ->
				\(conv:c -> {nixExpr:Text}) ->
						\(attrF: AttrF c) -> attrF.attrName )
		⊢ \(res:Text) ->
				r.config {nixExpr:Text}
							( \(c:Type)
									-> \(conv:c -> NodeConf)
									-> \(attrF: AttrF c)
									-> conv (attrF.attrParse res) )
 -
 - We could write a function in Dhall (or in Haskell, expr -> expr) that replaces all resources
 - with a pair
 -    { attrName : Text, attrCont : DynVal|Text -> NodeConf, tfDecls : Text }
 - Render the above as a single TF file (this is impossible in Dhall!)
 -
 -
 - NOTE currently NodeConf is Text, so the above also works with virtualization (e.g. for AMI/Docker,
 - create a packer script starting from a base image and provisioning with the Nix expression).
 - If NodeConf is changed to a *function*, the evaluator will use some Dhall backend to convert
 - this to a runnable image. This could work in several ways:
 -    Blob -> Blob                 Become a (pure) web server
 -    Blob -> State Blob Blob      Become a web server with (transient) state, backed by its own harddrive
 -    Blob -> NodeConf             Wait for a web request, then *become* the given config
 -    Blob -> Map Text NodeConf    Wait for a web request, then *launch new nodes* with the given config
 -    A -> B                       Become a processor in a typed channel
 -
 -
 - TODO LATER special resources for cached provisions (AMIs/containers)
 - AMI-based, implemented by running packer on host machine:
 -  * Resource a la AwsInstance that builds the NodeConf to an AMI and returns registered AMI
 -  * Resource a la AwsInstance that takes such an AMI instead of a NodeConf
 -
 -
 -
 - Implementation
 -   Make name depend of TF config (including Nix expr) - reuse if exists in AWS account
 -   Use external data source to call packer (with HS wrapper?)
 -     Generates suitable JSON for packer and calls this
 -       https://www.packer.io/docs/builders/amazon-ebs.html
 -   Provide output attribute with the new AMI name
 -   Provide this as an alternative input to AwsInstance

 - Docker-based, implemented by running docker+packer on a special instance:
 -  * Resource a la AwsInstance that builds a NodeConf to a Docker container placed in ECR
 -  * Resource that launches containers in EKS
 -
 -
 -
 -
 -
 - TODO LATER
 -    Provision a function (e.g. Text -> Text).
 -
 -    Provision a node with config (e.g. A -> NodeConf)
 -
 -
 -
 - TODO LATER
 -
 - Break recursive dependency between attrs/resources (using limited fixpoints?) to define safe
 - mappings between resources/attrs (e.g. prevent looking up an attr of resource of type A from
 - resource of type B).
 -
 - Or use something like the NOTE [Safe attributes] approach, hiding the Attr constructors and
 - passing in a safe subset at the top level.
 -
 -}

[ AwsResources.AwsInstance
  { name = "x"
  , staticFiles = noFiles
  , config =
    	liftA2Attr Text Text NodeConf toNix2 someAttr someAttr
  }
]

-- TODO make use of the following Kubernetes networking notes
--    A kub cluster is a set of machines on a private network running nodes (controllers and workers). Each worker maintains a collection of pods (sets of containers with shared networking/disk, basically virtual computers with a set of services).
--
--    In any private k8s network you have IPs for nodes ('actual' machines), Pods and Services (faked, using iptables).
--    To expose them externally, use NodePort/LoadBalancer/Ingress

-- TODO do more: https://www.whizlabs.com/
--  Esp. the security certificates

-- TODO FIXME If provisioner fails, EC2 instances are not tainted in TF (presumably because only the fake
-- null resource we generate actually fails to provision - those were added to ensure the Nix config is
-- always repushed when it has changed - alternative way of doing that?).
-- NOTE this is only a problem if the provisioner *breaks* the instance, e.g. by filling the harddrive

-- TODO IAM group/role/policy (e.g. create S3 bucket and give access to single instance)

-- TODO NOW S3 bucket creation/addition

-- TODO redis cluster (either ElastiCache or EC2+NixOS)

-- TODO RDS instance + user + database

-- TODO setup custom VPC with private subnet?

-- TODO test AWS SNS?

-- TODO NOW extend Docker/NixOS/EC2 to build a static set of containers
-- Push results to ECS (for now)
-- Extend testDocker to also install Packer+Terraform, build images, and push to ECS
--      pkgs.packer
--      pkgs.terraform

-- TODO Gitlab + Pipeline that builds docker images (isolated from Internet to assure pure functin of commit)
--  + orchestration in k8s/EKS or Nomad/NixOS/EC2


-- TODO get TF to boot EKS cluster and run standard containers in there (e.g. consul cluster)

-- TODO NixOS machine with docker + standard consul image
-- E.g. as above, then run:
-- 		docker pull consul
-- 		docker run -t -i consul agent -bootstrap-expect=1 -server


-- TODO build custom Docker images using NixOS (preferably driven by expressions, similar to our NixOS provisioning)
--   See: https://nixos.wiki/wiki/Docker

-- TODO Consul cluster based on Docker+Kubernetes?
-- TODO more generally: config/launch containers in EKS, or functions in Lambda as an alternative to NixOS/EC2

-- TODO use packer to build AMIs/Docker containers

-- TODO [NOTE pinNixPkgs] pin nixpkgs on the machines/AMI?
-- See:
--    http://www.haskellforall.com/2018/08/nixos-in-production.html

-- TODO configurable EC2 instance type/size

-- TODO something like
--    https://itnext.io/building-a-kubernetes-hybrid-cloud-with-terraform-fe15164b35fb


--
-- TODO simple test suite
-- Should take
--    [{norosExpr:Text,expectedEndpoint:Text,timeout:Natural}]
-- deploys a bunch of expressions in sequence and verifies the
-- given URL comes up within the given time.
-- Note some 'test' fields sketched above.
